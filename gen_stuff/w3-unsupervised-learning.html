<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éç›£ç£å¼å­¸ç¿’ï¼šå¤œå¸‚ç¾é£Ÿç­–å±•äºº</title>
    <style>
        :root {
            --bg-color: #F4F2EF;
            --panel-color: #ffffff;
            --primary-text: #5a5a5a;
            --secondary-text: #8c867b;
            --accent-color: #78785b;
            --border-color: #d1d1c2;
        }
        body {
            font-family: 'Calibri', 'Noto Sans TC', sans-serif;
            background-color: var(--bg-color);
            color: var(--primary-text);
            margin: 0;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            width: 100%;
            max-width: 1000px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .panel {
            background-color: var(--panel-color);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            border: 1px solid var(--border-color);
        }
        h1, h2 {
            text-align: center;
            margin: 0 0 15px 0;
        }
        h1 { font-size: 2em; color: var(--primary-text); }
        h2 { font-size: 1.5em; color: var(--secondary-text); }

        #market-space {
            position: relative;
            width: 100%;
            height: 500px;
            background-color: #faf6f1;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            margin-top: 15px;
            touch-action: none; /* For mobile dragging */
        }
        .stall {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px;
            border-radius: 8px;
            background-color: var(--panel-color);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            cursor: grab;
            user-select: none;
            border: 2px solid var(--border-color);
        }
        .stall.dragging {
            cursor: grabbing;
            opacity: 0.8;
            transform: scale(1.1);
            z-index: 1000;
        }
        .stall .icon { font-size: 2.5em; }
        .stall .name { font-weight: bold; font-size: 0.9em; }

        .button-container {
            text-align: center;
            margin-top: 20px;
        }
        button {
            font-size: 1.1em;
            padding: 12px 25px;
            border-radius: 8px;
            border: none;
            color: white;
            background-color: var(--accent-color);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.1);
        }

        #analysis-result {
            margin-top: 20px;
            padding: 15px;
            background-color: #faf6f1;
            border-radius: 8px;
        }

        @media (max-width: 600px) {
            #market-space { height: 400px; }
            .stall .icon { font-size: 2em; }
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>éç›£ç£å¼å­¸ç¿’ï¼šå¤œå¸‚ç¾é£Ÿç­–å±•äºº</h1>
        <p style="text-align:center; color: var(--secondary-text);">ä½ ä¾†åˆ°ä¸€å€‹å…¨æ–°çš„å¤œå¸‚ï¼Œé€™è£¡æ²’æœ‰ä»»ä½•æ¨™ç¤ºã€‚è«‹æ‹–æ›³æ”¤ä½ï¼Œå°‡ä½ èªç‚ºç›¸ä¼¼çš„æ”¾åœ¨ä¸€èµ·ï¼Œè‡ªè¡Œå®šç¾©å‡ºç¾é£Ÿå€ï¼</p>
    </header>

    <div class="panel">
        <h2>ç¬¬ä¸€æ­¥ï¼šæ¢ç´¢èˆ‡åˆ†ç¾¤ (è‡ªè¡Œæ‰¾å‡ºçµæ§‹)</h2>
        <div id="market-space">
            </div>
    </div>

    <div class="panel">
        <h2>ç¬¬äºŒæ­¥ï¼šåˆ†æèˆ‡è©®é‡‹ (ç‚ºç¾¤é«”è³¦äºˆæ„ç¾©)</h2>
        <p>ç•¶ä½ å®Œæˆåˆ†ç¾¤å¾Œï¼Œé»æ“Šä¸‹æ–¹æŒ‰éˆ•ï¼Œè®“ AI åˆ†æä½ çš„åˆ†ç¾¤çµæœï¼Œçœ‹çœ‹ä½ ç™¼ç¾äº†å“ªäº›éš±è—çš„ç¾é£Ÿä¸»é¡Œï¼</p>
        <div class="button-container">
            <button id="analyze-btn">åˆ†ææˆ‘çš„ç¾é£Ÿåœ°åœ–</button>
        </div>
        <div id="analysis-result">
            <p>åˆ†æçµæœå°‡é¡¯ç¤ºæ–¼æ­¤...</p>
        </div>
    </div>
</div>

<script>
    const foodStalls = [
        // Hidden properties: cuisine, type
        { name: 'å£½å¸', icon: 'ğŸ£', cuisine: 'æ—¥å¼', type: 'ä¸»é£Ÿ' },
        { name: 'æ‹‰éºµ', icon: 'ğŸœ', cuisine: 'æ—¥å¼', type: 'ä¸»é£Ÿ' },
        { name: 'ç« é­šç‡’', icon: 'ğŸ™', cuisine: 'æ—¥å¼', type: 'é»å¿ƒ' },
        { name: 'ç‰›æ’', icon: 'ğŸ¥©', cuisine: 'è¥¿å¼', type: 'ä¸»é£Ÿ' },
        { name: 'ç¾©å¤§åˆ©éºµ', icon: 'ğŸ', cuisine: 'è¥¿å¼', type: 'ä¸»é£Ÿ' },
        { name: 'æ¼¢å ¡', icon: 'ğŸ”', cuisine: 'è¥¿å¼', type: 'ä¸»é£Ÿ' },
        { name: 'ç‰ç±³ç‰‡', icon: ' nachos', icon: 'ğŸŒ®', cuisine: 'å¢¨è¥¿å“¥', type: 'é»å¿ƒ' },
        { name: 'å¢¨è¥¿å“¥æ²', icon: 'ğŸŒ¯', cuisine: 'å¢¨è¥¿å“¥', type: 'ä¸»é£Ÿ' },
        { name: 'çç å¥¶èŒ¶', icon: 'ğŸ§‹', cuisine: 'å°å¼', type: 'é£²æ–™' },
        { name: 'é›æ’', icon: 'ğŸ—', cuisine: 'å°å¼', type: 'é»å¿ƒ' },
        { name: 'è‡­è±†è…', icon: 'ğŸ¢', cuisine: 'å°å¼', type: 'é»å¿ƒ' },
    ];

    const marketSpace = document.getElementById('market-space');
    const analyzeBtn = document.getElementById('analyze-btn');
    const analysisResult = document.getElementById('analysis-result');
    let stalls = [];

    function initializeStalls() {
        marketSpace.innerHTML = '';
        stalls = foodStalls.map(stallData => {
            const el = document.createElement('div');
            el.className = 'stall';
            el.innerHTML = `<div class="icon">${stallData.icon}</div><div class="name">${stallData.name}</div>`;

            const marketRect = marketSpace.getBoundingClientRect();
            const x = Math.random() * (marketRect.width - 60);
            const y = Math.random() * (marketRect.height - 60);
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;

            marketSpace.appendChild(el);

            return { ...stallData, element: el };
        });

        makeAllDraggable();
    }

    function makeAllDraggable() {
        stalls.forEach(stall => {
            let active = false;
            let currentX, currentY, initialX, initialY, xOffset = 0, yOffset = 0;

            const dragStart = (e) => {
                stall.element.classList.add('dragging');
                if (e.type === "touchstart") {
                    initialX = e.touches[0].clientX - xOffset;
                    initialY = e.touches[0].clientY - yOffset;
                } else {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                }
                active = true;
            };

            const drag = (e) => {
                if (active) {
                    e.preventDefault();
                    if (e.type === "touchmove") {
                        currentX = e.touches[0].clientX - initialX;
                        currentY = e.touches[0].clientY - initialY;
                    } else {
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                    }

                    const marketRect = marketSpace.getBoundingClientRect();
                    const stallWidth = stall.element.offsetWidth;
                    const stallHeight = stall.element.offsetHeight;
                    const originalLeft = parseFloat(stall.element.style.left);
                    const originalTop = parseFloat(stall.element.style.top);

                    const minX = -originalLeft;
                    const maxX = marketRect.width - originalLeft - stallWidth;
                    const minY = -originalTop;
                    const maxY = marketRect.height - originalTop - stallHeight;

                    currentX = Math.max(minX, Math.min(currentX, maxX));
                    currentY = Math.max(minY, Math.min(currentY, maxY));

                    xOffset = currentX;
                    yOffset = currentY;
                    setTranslate(currentX, currentY, stall.element);
                }
            };

            const dragEnd = () => {
                stall.element.classList.remove('dragging');
                initialX = currentX;
                initialY = currentY;
                active = false;
            };

            stall.element.addEventListener("mousedown", dragStart, false);
            document.addEventListener("mouseup", dragEnd, false);
            document.addEventListener("mousemove", drag, false);

            stall.element.addEventListener("touchstart", dragStart, false);
            document.addEventListener("touchend", dragEnd, false);
            document.addEventListener("touchmove", drag, {passive: false});
        });
    }

    function setTranslate(xPos, yPos, el) {
        el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
    }

    analyzeBtn.addEventListener('click', () => {
        // Simple clustering based on proximity
        const CLUSTER_THRESHOLD = 150; // pixels
        let clusters = [];
        let assignedStalls = new Set();

        stalls.forEach(s1 => {
            if (assignedStalls.has(s1.name)) return;

            let currentCluster = [s1];
            assignedStalls.add(s1.name);

            stalls.forEach(s2 => {
                if (!assignedStalls.has(s2.name)) {
                    const rect1 = s1.element.getBoundingClientRect();
                    const rect2 = s2.element.getBoundingClientRect();
                    const distance = Math.hypot(rect1.x - rect2.x, rect1.y - rect2.y);

                    if (distance < CLUSTER_THRESHOLD) {
                        currentCluster.push(s2);
                        assignedStalls.add(s2.name);
                    }
                }
            });
            clusters.push(currentCluster);
        });

        // Interpret and display results
        let htmlResult = `<h3>AI åˆ†æäº†ä½ çš„ç¾é£Ÿåœ°åœ–ï¼š</h3>`;
        htmlResult += `<p>ä½ å°‡ ${stalls.length} å€‹æ”¤ä½åˆ†æˆäº† <strong>${clusters.length}</strong> å€‹ä¸»è¦çš„ç¾é£Ÿå€ã€‚é€™æ˜¯ä¸€ç¨®éç›£ç£å¼å­¸ç¿’ï¼Œé‡é»åœ¨æ–¼ä½ å¦‚ä½•è³¦äºˆé€™äº›ç¾¤é«”æ„ç¾©ï¼š</p><ul>`;

        clusters.forEach((cluster, index) => {
            const cuisineCounts = {};
            cluster.forEach(stall => {
                cuisineCounts[stall.cuisine] = (cuisineCounts[stall.cuisine] || 0) + 1;
            });

            // Find dominant cuisine
            let dominantCuisine = 'ç¶œåˆ';
            let maxCount = 0;
            for (const cuisine in cuisineCounts) {
                if (cuisineCounts[cuisine] > maxCount) {
                    maxCount = cuisineCounts[cuisine];
                    dominantCuisine = cuisine;
                }
            }

            htmlResult += `<li><strong>ç¾é£Ÿå€ ${index + 1}</strong> (åŒ…å« ${cluster.length} å€‹æ”¤ä½): AI æ¨æ¸¬é€™å¯èƒ½æ˜¯ã€Œ<strong>${dominantCuisine}ä¸»é¡Œå€</strong>ã€ã€‚<br><small>æˆå“¡: ${cluster.map(s => s.name).join(', ')}</small></li>`;
        });

        htmlResult += `</ul><p>çœ‹åˆ°äº†å—ï¼Ÿå³ä½¿æ²’æœ‰æ¨™æº–ç­”æ¡ˆï¼Œæ•¸æ“šä¸­çš„çµæ§‹ä¹Ÿèƒ½è¢«ã€Œç™¼ç¾ã€ã€‚é€™å°±æ˜¯éç›£ç£å¼å­¸ç¿’çš„é­…åŠ›ï¼</p>`;
        analysisResult.innerHTML = htmlResult;
    });

    initializeStalls();

</script>

</body>
</html>